---
phase: 06-radio-data-layer-audio-hook
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAudioPlayer.ts
autonomous: false

must_haves:
  truths:
    - "Developer can import and use useAudioPlayer in any Next.js client component"
    - "next build succeeds without ReferenceError: Audio is not defined"
    - "Audio element is only instantiated inside useEffect, never at module scope or hook body"
    - "Hook exposes load, play, pause functions and state/currentUrl reactive values"
  artifacts:
    - path: "src/hooks/useAudioPlayer.ts"
      provides: "SSR-safe audio playback hook"
      exports: ["useAudioPlayer", "AudioState"]
      contains: "use client"
  key_links:
    - from: "src/hooks/useAudioPlayer.ts"
      to: "HTMLAudioElement"
      via: "useEffect initialization"
      pattern: "useEffect.*new Audio"
---

<objective>
Create an SSR-safe useAudioPlayer hook that manages HTML audio playback without crashing Next.js build, then verify CORS compatibility with the F1 CDN from a deployed Vercel origin.

Purpose: Phase 7 needs a sticky audio player that plays team radio MP3 files. The Audio API only exists in browsers — instantiating it during Next.js SSR/build crashes with "Audio is not defined". This hook isolates the browser-only code behind useEffect. The CORS smoke test validates that the F1 CDN allows cross-origin audio before Phase 7 builds UI around it.

Output: `src/hooks/useAudioPlayer.ts` hook file, confirmed `next build` success, and CORS validation result.
</objective>

<execution_context>
@/Users/owner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-radio-data-layer-audio-hook/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSR-safe useAudioPlayer hook and verify build</name>
  <files>src/hooks/useAudioPlayer.ts</files>
  <action>
Create `src/hooks/useAudioPlayer.ts` with `"use client"` directive at the top.

**Exported types:**
```typescript
export type AudioState = "idle" | "loading" | "playing" | "paused" | "error";
```

**Hook implementation:**
```typescript
export function useAudioPlayer() { ... }
```

Internal state:
- `audioRef = useRef<HTMLAudioElement | null>(null)` — holds the Audio instance, never triggers re-renders
- `[state, setState] = useState<AudioState>("idle")` — reactive playback state
- `[currentUrl, setCurrentUrl] = useState<string | null>(null)` — currently loaded URL

**useEffect (empty deps array — runs once on mount):**
1. Guard: `if (typeof window === "undefined") return;` — belt-and-suspenders, though useEffect alone is sufficient
2. Create: `audioRef.current = new Audio();`
3. Add event listeners on `audioRef.current`:
   - `"playing"` → `setState("playing")`
   - `"pause"` → `setState("paused")`
   - `"ended"` → `setState("idle")`
   - `"error"` → `setState("error")`
   - `"loadstart"` → `setState("loading")`
   - `"canplay"` → if state was "loading", set to "paused" (loaded but not auto-playing)
4. Cleanup: `el.pause(); el.removeAttribute("src"); el.load();` — stops playback and releases resources. Remove all event listeners.

IMPORTANT: Store event listener references in named functions (not inline arrows) so removeEventListener works correctly in cleanup.

**Callbacks (all wrapped in useCallback):**
- `load(url: string)` — sets `audioRef.current.src = url`, calls `audioRef.current.load()`, sets `setCurrentUrl(url)`
- `play()` — calls `audioRef.current.play()` (returns Promise, catch sets error state)
- `pause()` — calls `audioRef.current.pause()`
- `stop()` — calls `pause()`, resets `audioRef.current.currentTime = 0`, sets state to "idle", sets currentUrl to null

**Return value:**
```typescript
return { state, currentUrl, load, play, pause, stop } as const;
```

CRITICAL: `new Audio()` must ONLY appear inside the useEffect callback. If it appears in the hook body, module scope, or any non-useEffect code path, `next build` will crash with `ReferenceError: Audio is not defined`.
  </action>
  <verify>
1. Run `npm run build` — must succeed with zero errors. If build fails with "Audio is not defined", the hook has SSR-unsafe code.
2. Run `npx tsc --noEmit` — TypeScript compiles cleanly.
3. Verify `"use client"` is the first line: `head -1 src/hooks/useAudioPlayer.ts` should output `"use client";`
4. Verify no `new Audio()` outside useEffect: `grep -n "new Audio" src/hooks/useAudioPlayer.ts` — should only appear inside the useEffect block (within lines that are clearly inside the effect callback).
  </verify>
  <done>
`useAudioPlayer` hook exists with "use client" directive. `new Audio()` only appears inside useEffect. `npm run build` succeeds without "Audio is not defined" error. Hook exports AudioState type and useAudioPlayer function with load/play/pause/stop controls.
  </done>
</task>

<task type="checkpoint:human-verify" gate="non-blocking">
  <name>Task 2: CORS smoke test — verify F1 CDN audio plays from Vercel</name>
  <files>none (verification only)</files>
  <action>
**What was built:** The useAudioPlayer hook (Task 1) and the full OpenF1 data layer (Plan 01). Together these enable fetching a real recording_url from the OpenF1 API and attempting audio playback from a deployed origin.

**Human verification required — CORS smoke test:**

**Option A — Quick browser console test (preferred):**
1. Deploy the current branch to Vercel (or use existing Vercel preview URL)
2. Open browser DevTools console on the deployed URL
3. Run this JavaScript in the console:
```javascript
const a = new Audio("https://livetiming.formula1.com/static/2024/2024-03-09_Saudi_Arabian_Grand_Prix/2024-03-07_Practice_1/TeamRadio/MAXVER01_1_20240307_141852.mp3");
a.play().then(() => console.log("CORS OK — audio plays")).catch(e => console.error("CORS BLOCKED:", e));
```
4. If you hear audio and see "CORS OK" → CORS is fine, Phase 7 can proceed as planned
5. If you see "CORS BLOCKED" or a network CORS error → need to implement `/api/radio-proxy` before Phase 7

**Option B — If the specific URL above is expired or returns 404:**
1. Fetch a real recording_url: `fetch("https://api.openf1.org/v1/team_radio?session_key=9158&driver_number=1").then(r=>r.json()).then(d=>console.log(d[0].recording_url))`
2. Use that URL in the Audio test above

**Note:** This checkpoint is non-blocking. The result determines whether Phase 7 needs a proxy route or can use direct CDN URLs. Record the outcome in the SUMMARY. If CORS is blocked, add a note to STATE.md blockers that `/api/radio-proxy` must be created at the start of Phase 7.
  </action>
  <verify>
User reports one of: "CORS OK", "CORS BLOCKED", or "DEFERRED".
  </verify>
  <done>
CORS behavior of livetiming.formula1.com is documented. If blocked, Phase 7 plan includes /api/radio-proxy. If OK, Phase 7 uses direct CDN URLs. If deferred, Phase 7 must handle both cases.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds — no SSR crashes from Audio or window references
2. `npx tsc --noEmit` passes
3. useAudioPlayer.ts has `"use client"` as first line
4. CORS test result documented (OK, BLOCKED, or DEFERRED)
</verification>

<success_criteria>
- useAudioPlayer hook works in Next.js client components without SSR crashes
- Build succeeds confirming SSR safety
- CORS behavior of F1 CDN is known (or documented as deferred)
</success_criteria>

<output>
After completion, create `.planning/phases/06-radio-data-layer-audio-hook/06-03-SUMMARY.md`
</output>
