---
phase: 06-radio-data-layer-audio-hook
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/openf1/types.ts
  - src/lib/api/openf1/endpoints.ts
  - src/lib/api/openf1/query-keys.ts
  - src/hooks/useTeamRadio.ts
  - src/hooks/useRaceControl.ts
  - src/hooks/useOpenF1Sessions.ts
  - src/hooks/useOpenF1Meetings.ts
  - src/hooks/useDriverLaps.ts
  - src/hooks/usePositions.ts
autonomous: true

must_haves:
  truths:
    - "Developer can import fetchTeamRadio, fetchRaceControl, fetchSessions, fetchMeetings, fetchDriverLaps, fetchPositions and receive correctly typed responses"
    - "Developer can use useTeamRadio, useRaceControl, useOpenF1Sessions, useOpenF1Meetings, useDriverLaps, usePositions hooks with staleTime: Infinity and session-scoped query keys"
    - "All six hooks use skipToken when required parameters are undefined, preventing unnecessary API calls"
  artifacts:
    - path: "src/lib/api/openf1/types.ts"
      provides: "OpenF1RaceControl, OpenF1Session, OpenF1Meeting type definitions"
      contains: "OpenF1RaceControl"
    - path: "src/lib/api/openf1/endpoints.ts"
      provides: "Six typed fetch functions for OpenF1 API"
      exports: ["fetchTeamRadio", "fetchRaceControl", "fetchSessions", "fetchMeetings", "fetchDriverLaps", "fetchPositions"]
    - path: "src/lib/api/openf1/query-keys.ts"
      provides: "Hierarchical query key factory for OpenF1 hooks"
      exports: ["openf1Keys"]
    - path: "src/hooks/useTeamRadio.ts"
      provides: "React Query hook for team radio data"
      exports: ["useTeamRadio"]
    - path: "src/hooks/useRaceControl.ts"
      provides: "React Query hook for race control events"
      exports: ["useRaceControl"]
    - path: "src/hooks/useOpenF1Sessions.ts"
      provides: "React Query hook for session listings"
      exports: ["useOpenF1Sessions"]
    - path: "src/hooks/useOpenF1Meetings.ts"
      provides: "React Query hook for meeting listings"
      exports: ["useOpenF1Meetings"]
    - path: "src/hooks/useDriverLaps.ts"
      provides: "React Query hook for per-driver lap data"
      exports: ["useDriverLaps"]
    - path: "src/hooks/usePositions.ts"
      provides: "React Query hook for position data"
      exports: ["usePositions"]
  key_links:
    - from: "src/lib/api/openf1/endpoints.ts"
      to: "src/lib/api/openf1/client.ts"
      via: "openf1Fetch import"
      pattern: "import.*openf1Fetch.*from.*client"
    - from: "src/hooks/useTeamRadio.ts"
      to: "src/lib/api/openf1/endpoints.ts"
      via: "fetchTeamRadio import"
      pattern: "import.*fetchTeamRadio.*from.*endpoints"
    - from: "src/hooks/useTeamRadio.ts"
      to: "src/lib/api/openf1/query-keys.ts"
      via: "openf1Keys import"
      pattern: "import.*openf1Keys.*from.*query-keys"
---

<objective>
Create the complete OpenF1 data layer: typed fetch functions for six endpoints, a session-scoped query key factory, and six React Query hooks.

Purpose: Phase 7 and Phase 8 UI components need to consume team radio, race control, sessions, meetings, laps, and positions data through hooks. This plan establishes the entire data fetching infrastructure following the exact patterns already established by the Jolpica data layer (Phase 2).

Output: 3 new files in `src/lib/api/openf1/` (endpoints.ts, query-keys.ts) + extended types.ts, and 6 new hook files in `src/hooks/`.
</objective>

<execution_context>
@/Users/owner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/api/openf1/client.ts
@src/lib/api/openf1/types.ts
@src/lib/api/jolpica/query-keys.ts
@src/lib/api/jolpica/endpoints.ts
@src/hooks/useRaces.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new types, create endpoints.ts, and create query-keys.ts</name>
  <files>
    src/lib/api/openf1/types.ts
    src/lib/api/openf1/endpoints.ts
    src/lib/api/openf1/query-keys.ts
  </files>
  <action>
**1. Extend `src/lib/api/openf1/types.ts`** — Add three new interfaces after the existing types:

- `OpenF1RaceControl`: category (string), date (string), driver_number (number | null), flag (string | null), lap_number (number | null), meeting_key (number), message (string), qualifying_phase (number | null), scope (string | null), sector (number | null), session_key (number)
- `OpenF1Session`: circuit_key (number), circuit_short_name (string), country_code (string), country_key (number), country_name (string), date_end (string), date_start (string), gmt_offset (string), location (string), meeting_key (number), session_key (number), session_name (string), session_type (string), year (number)
- `OpenF1Meeting`: circuit_key (number), circuit_image (string), circuit_info_url (string), circuit_short_name (string), circuit_type (string), country_code (string), country_flag (string), country_key (number), country_name (string), date_end (string), date_start (string), gmt_offset (string), location (string), meeting_key (number), meeting_name (string), meeting_official_name (string), year (number)

Field names and types verified against OpenF1 API docs (2026-02-19). Add JSDoc comments matching the style of existing types.

**2. Create `src/lib/api/openf1/endpoints.ts`** — Six async fetch functions mirroring the Jolpica endpoints.ts pattern:

```typescript
import { openf1Fetch } from "@/lib/api/openf1/client";
import type { ... } from "@/lib/api/openf1/types";
```

Functions:
- `fetchTeamRadio(sessionKey: number): Promise<OpenF1TeamRadio[]>` — calls `/team_radio?session_key=${sessionKey}`
- `fetchRaceControl(sessionKey: number): Promise<OpenF1RaceControl[]>` — calls `/race_control?session_key=${sessionKey}`
- `fetchSessions(year: number): Promise<OpenF1Session[]>` — calls `/sessions?year=${year}`
- `fetchMeetings(year: number): Promise<OpenF1Meeting[]>` — calls `/meetings?year=${year}`
- `fetchDriverLaps(sessionKey: number, driverNumber: number): Promise<OpenF1LapData[]>` — calls `/laps?session_key=${sessionKey}&driver_number=${driverNumber}`
- `fetchPositions(sessionKey: number, driverNumber: number): Promise<OpenF1Position[]>` — calls `/position?session_key=${sessionKey}&driver_number=${driverNumber}` (IMPORTANT: always filter by driver_number to avoid 100K+ record response — per research findings on position data volume)

**3. Create `src/lib/api/openf1/query-keys.ts`** — Hierarchical query key factory mirroring `jolpikaKeys`:

```typescript
export const openf1Keys = {
  all: ["openf1"] as const,
  teamRadio: (sessionKey: number) => [...openf1Keys.all, sessionKey, "team-radio"] as const,
  raceControl: (sessionKey: number) => [...openf1Keys.all, sessionKey, "race-control"] as const,
  sessions: (year: number) => [...openf1Keys.all, "sessions", year] as const,
  meetings: (year: number) => [...openf1Keys.all, "meetings", year] as const,
  driverLaps: (sessionKey: number, driverNumber: number) => [...openf1Keys.all, sessionKey, "laps", driverNumber] as const,
  positions: (sessionKey: number, driverNumber: number) => [...openf1Keys.all, sessionKey, "positions", driverNumber] as const,
} as const;
```

Session-scoped keys include `sessionKey` at position 1 so `invalidateQueries({ queryKey: ['openf1', sessionKey] })` clears all data for a session. The `positions` key includes `driverNumber` because the fetch is always per-driver.
  </action>
  <verify>
Run `npx tsc --noEmit` — should compile with zero errors. Verify all six endpoint functions exist by checking the exports: `grep "export async function" src/lib/api/openf1/endpoints.ts` should show 6 functions.
  </verify>
  <done>
Three files exist: types.ts has OpenF1RaceControl, OpenF1Session, OpenF1Meeting interfaces; endpoints.ts has 6 typed fetch functions importing from client.ts; query-keys.ts has openf1Keys factory with session-scoped keys. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create six React Query hooks</name>
  <files>
    src/hooks/useTeamRadio.ts
    src/hooks/useRaceControl.ts
    src/hooks/useOpenF1Sessions.ts
    src/hooks/useOpenF1Meetings.ts
    src/hooks/useDriverLaps.ts
    src/hooks/usePositions.ts
  </files>
  <action>
Create six hook files following the exact pattern of `src/hooks/useRaces.ts`:

Each hook:
1. Imports `skipToken` and `useQuery` from `@tanstack/react-query`
2. Imports the corresponding fetch function from `@/lib/api/openf1/endpoints`
3. Imports `openf1Keys` from `@/lib/api/openf1/query-keys`
4. Accepts parameter(s) as `number | undefined`
5. Uses `skipToken` when parameter is undefined (not `enabled: false` — per project decision from Phase 2)
6. Sets `staleTime: Infinity` explicitly (historical data is immutable)

**useTeamRadio.ts:**
```typescript
import { skipToken, useQuery } from "@tanstack/react-query";
import { fetchTeamRadio } from "@/lib/api/openf1/endpoints";
import { openf1Keys } from "@/lib/api/openf1/query-keys";

export function useTeamRadio(sessionKey: number | undefined) {
  return useQuery({
    queryKey: openf1Keys.teamRadio(sessionKey ?? 0),
    queryFn: sessionKey ? () => fetchTeamRadio(sessionKey) : skipToken,
    staleTime: Infinity,
  });
}
```

**useRaceControl.ts:** Same pattern — `sessionKey: number | undefined`, uses `openf1Keys.raceControl(sessionKey ?? 0)` and `fetchRaceControl(sessionKey)`.

**useOpenF1Sessions.ts:** Param is `year: number | undefined`, uses `openf1Keys.sessions(year ?? 0)` and `fetchSessions(year)`.

**useOpenF1Meetings.ts:** Param is `year: number | undefined`, uses `openf1Keys.meetings(year ?? 0)` and `fetchMeetings(year)`.

**useDriverLaps.ts:** Two params — `sessionKey: number | undefined, driverNumber: number | undefined`. Both must be defined to fetch. Uses `openf1Keys.driverLaps(sessionKey ?? 0, driverNumber ?? 0)` and `sessionKey && driverNumber ? () => fetchDriverLaps(sessionKey, driverNumber) : skipToken`.

**usePositions.ts:** Two params — `sessionKey: number | undefined, driverNumber: number | undefined`. Both must be defined. Uses `openf1Keys.positions(sessionKey ?? 0, driverNumber ?? 0)` and `sessionKey && driverNumber ? () => fetchPositions(sessionKey, driverNumber) : skipToken`.
  </action>
  <verify>
Run `npx tsc --noEmit` — should compile with zero errors. Each hook file should import from openf1 endpoints and query-keys (not jolpica). Verify hook count: `ls src/hooks/use*.ts | wc -l` should show 17 total (11 existing + 6 new).
  </verify>
  <done>
Six new hook files exist in `src/hooks/`. Each uses skipToken pattern, staleTime: Infinity, and session-scoped query keys from openf1Keys factory. TypeScript compiles cleanly. All hooks follow the established useRaces.ts pattern.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/lib/api/openf1/endpoints.ts` exports 6 functions that all call `openf1Fetch`
3. `src/lib/api/openf1/query-keys.ts` exports `openf1Keys` with 6 key generators
4. All 6 hooks use `skipToken`, `staleTime: Infinity`, and import from openf1 (not jolpica)
5. `npm run build` succeeds (no SSR issues — these files are pure data, no browser APIs)
</verification>

<success_criteria>
- All 6 endpoint functions are importable and correctly typed
- All 6 hooks return React Query results with proper caching
- Query keys are session-scoped (include sessionKey at position 1)
- TypeScript compilation succeeds with no errors
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-radio-data-layer-audio-hook/06-01-SUMMARY.md`
</output>
