---
phase: 06-radio-data-layer-audio-hook
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - vitest.config.ts
  - package.json
  - src/lib/utils/radio/correlateRadioContext.ts
  - src/lib/utils/radio/__tests__/correlateRadioContext.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can call correlateRadioContext(radio, laps, positions) and receive enriched radio objects with lap_number and position fields"
    - "Binary search correctly finds the nearest preceding lap and position for each radio timestamp"
    - "Returns null for lap_number and position when no preceding data exists"
    - "Handles empty arrays, single-element arrays, and unsorted input gracefully"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest test runner configuration with @/ alias"
      contains: "defineConfig"
    - path: "src/lib/utils/radio/correlateRadioContext.ts"
      provides: "correlateRadioContext function and RadioWithContext type"
      exports: ["correlateRadioContext", "RadioWithContext"]
    - path: "src/lib/utils/radio/__tests__/correlateRadioContext.test.ts"
      provides: "Test suite for binary search correlation"
      contains: "correlateRadioContext"
  key_links:
    - from: "src/lib/utils/radio/correlateRadioContext.ts"
      to: "src/lib/api/openf1/types.ts"
      via: "type imports"
      pattern: "import type.*OpenF1TeamRadio.*OpenF1LapData.*OpenF1Position"
---

<objective>
Implement and test the correlateRadioContext utility that maps radio message timestamps to lap numbers and driver positions using binary search.

Purpose: Phase 7 and Phase 8 need to display "Lap 23, P3" next to each radio message. This utility takes the raw radio array, laps array, and positions array and enriches each radio message with the nearest preceding lap number and position. Binary search is required because position arrays can be 5–15K records per driver — linear scan would be visibly slow.

Output: One source file (`correlateRadioContext.ts`) and one test file with comprehensive coverage of edge cases.
</objective>

<execution_context>
@/Users/owner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/owner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/lib/api/openf1/types.ts
</context>

<feature>
  <name>correlateRadioContext — binary search timestamp correlation</name>
  <files>
    src/lib/utils/radio/correlateRadioContext.ts
    src/lib/utils/radio/__tests__/correlateRadioContext.test.ts
  </files>
  <behavior>
    Given an array of OpenF1TeamRadio messages, an array of OpenF1LapData sorted by date_start, and an array of OpenF1Position sorted by date:

    1. For each radio message, find the latest lap whose date_start <= radio.date → set lap_number
    2. For each radio message, find the latest position whose date <= radio.date → set position
    3. If no preceding lap exists, lap_number = null
    4. If no preceding position exists, position = null
    5. The function defensively sorts both laps (by date_start) and positions (by date) before searching — OpenF1 API typically returns sorted but it is not guaranteed

    Edge cases:
    - Empty radio array → returns []
    - Empty laps array → all lap_numbers are null
    - Empty positions array → all positions are null
    - Radio timestamp before all laps → lap_number = null
    - Radio timestamp exactly matching a lap timestamp → uses that lap (<=, not <)
    - Multiple radio messages → each independently correlated
    - Single lap, single position → binary search still works (lo=hi=0)

    The RadioWithContext type extends OpenF1TeamRadio with:
    - lap_number: number | null
    - position: number | null

    Binary search algorithm (findPrecedingIndex):
    - Input: sorted string array of ISO 8601 dates, target date string
    - Output: index of latest entry where dates[i] <= target, or -1 if none
    - Uses lo/hi with unsigned right shift for midpoint: (lo + hi) >>> 1
    - ISO 8601 strings with consistent timezone sort correctly via string comparison (<=)
  </behavior>
  <implementation>
    **Step 0 — Install vitest (project has no test runner yet):**
    1. Run `npm install -D vitest` to add vitest as a devDependency
    2. Create `vitest.config.ts` at project root:
    ```typescript
    import { defineConfig } from "vitest/config";
    import path from "path";

    export default defineConfig({
      test: {
        include: ["src/**/__tests__/**/*.test.ts"],
      },
      resolve: {
        alias: {
          "@": path.resolve(__dirname, "./src"),
        },
      },
    });
    ```
    3. Add `"test": "vitest run"` to the `"scripts"` object in `package.json`

    This is the project's first test infrastructure — vitest is not currently installed and there are zero existing test files.

    **Step 1 — Implement correlateRadioContext:**
    Export `RadioWithContext` interface and `correlateRadioContext` function from `src/lib/utils/radio/correlateRadioContext.ts`.

    Internal `findPrecedingIndex(dates: string[], target: string): number` function — not exported, tested through the public API.

    The function:
    1. Defensive sort: `laps.slice().sort((a, b) => a.date_start.localeCompare(b.date_start))` and same for positions by `.date`
    2. Pre-extract date arrays: `sortedLaps.map(l => l.date_start)` and `sortedPositions.map(p => p.date)`
    3. Map over radio: for each message, binary search both date arrays, return enriched object

    Import types from `@/lib/api/openf1/types` — use `OpenF1TeamRadio`, `OpenF1LapData`, `OpenF1Position`.

    **Step 2 — Write tests:**
    Test file uses vitest. Create minimal test fixtures:
    - Helper function to create mock radio/lap/position objects with only required fields
    - 6-8 test cases covering: basic correlation, empty arrays, pre-race timestamps, exact timestamp match, multiple radio messages, unsorted input
  </implementation>
</feature>

<verification>
1. `npx vitest run src/lib/utils/radio/__tests__/correlateRadioContext.test.ts` — all tests pass
2. `npx tsc --noEmit` — compiles with zero errors
3. RadioWithContext type is exported and extends OpenF1TeamRadio
</verification>

<success_criteria>
- correlateRadioContext enriches each radio message with correct lap_number and position via binary search
- Edge cases (empty arrays, no preceding data, exact match) handled correctly
- All tests pass
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-radio-data-layer-audio-hook/06-02-SUMMARY.md`
</output>
